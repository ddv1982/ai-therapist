#!/usr/bin/env node
import fsp from 'node:fs/promises';
import path from 'node:path';
import { spawn } from 'node:child_process';
import yaml from 'js-yaml';

const projectRoot = path.resolve(process.cwd());
const specPath = path.resolve(projectRoot, 'docs/api.yaml');
const outDir = path.resolve(projectRoot, 'src/types/api');
const tmpDir = path.resolve(projectRoot, '.tmp/api-types');

/** Utilities **/
function toKebabCase(input) {
  return input
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/\s+/g, '-')
    .replace(/_+/g, '-')
    .toLowerCase();
}

function toNamespaceName(input) {
  return input
    .replace(/[^a-zA-Z0-9]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

async function exec(cmd, args, opts = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(cmd, args, { stdio: 'inherit', ...opts });
    child.on('close', (code) => {
      if (code === 0) resolve();
      else reject(new Error(`${cmd} ${args.join(' ')} exited with code ${code}`));
    });
    child.on('error', reject);
  });
}

async function main() {
  // Prepare dirs
  await fsp.rm(tmpDir, { recursive: true, force: true });
  await fsp.mkdir(tmpDir, { recursive: true });
  await fsp.rm(outDir, { recursive: true, force: true });
  await fsp.mkdir(outDir, { recursive: true });

  // Load full spec
  const specRaw = await fsp.readFile(specPath, 'utf8');
  const spec = yaml.load(specRaw);
  if (!spec || !spec.paths) {
    throw new Error('Invalid OpenAPI spec: missing paths');
  }

  // Collect tags from operations
  const tagToPaths = new Map();
  for (const [route, ops] of Object.entries(spec.paths)) {
    for (const [method, op] of Object.entries(ops)) {
      const methodLower = method.toLowerCase();
      if (
        !['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'].includes(methodLower)
      )
        continue;
      const tags = Array.isArray(op?.tags) ? op.tags : [];
      for (const tag of tags) {
        if (!tagToPaths.has(tag)) tagToPaths.set(tag, {});
        const pathsObj = tagToPaths.get(tag);
        if (!pathsObj[route]) pathsObj[route] = {};
        pathsObj[route][method] = op;
      }
    }
  }

  if (tagToPaths.size === 0) {
    console.warn('No tags found in spec; generating a single modular file');
    tagToPaths.set('Api', spec.paths);
  }

  const imports = [];
  const namespaces = [];

  // Generate per-tag specs and TS
  for (const [tag, pathsForTag] of tagToPaths.entries()) {
    const tagKebab = toKebabCase(tag);
    const tagNs = toNamespaceName(tag);
    const tagTmpSpec = {
      openapi: spec.openapi || '3.0.0',
      info: spec.info || { title: `API - ${tag}`, version: '1.0.0' },
      servers: spec.servers || [],
      tags: [{ name: tag }],
      paths: pathsForTag,
      // Keep components minimal: copy as-is; pruning is out of scope here
      components: spec.components || {},
    };
    const tmpSpecPath = path.join(tmpDir, `${tagKebab}.yaml`);
    await fsp.writeFile(tmpSpecPath, yaml.dump(tagTmpSpec), 'utf8');

    const outFile = path.join(outDir, `${tagKebab}.ts`);
    await exec('npx', ['openapi-typescript', tmpSpecPath, '-o', outFile]);

    imports.push(`import type * as ${tagNs} from './api/${tagKebab}';`);
    namespaces.push(tagNs);
  }

  // Build compatibility barrel that preserves existing imports
  const barrelLines = [];
  barrelLines.push('/**');
  barrelLines.push(' * Compatibility barrel generated by scripts/generate-api-types-modular.mjs');
  barrelLines.push(
    ' * This file preserves the previous openapi-typescript import surface by combining'
  );
  barrelLines.push(' * per-tag generated types into unified `paths` and `components` types.');
  barrelLines.push(' * Do not edit manually.');
  barrelLines.push(' */');
  barrelLines.push('');
  barrelLines.push(...imports);
  barrelLines.push('');
  if (namespaces.length === 0) {
    barrelLines.push('export type paths = Record<string, never>;');
    barrelLines.push('export type webhooks = Record<string, never>;');
    barrelLines.push('export interface components {');
    barrelLines.push('  schemas: Record<string, never>;');
    barrelLines.push('  responses: Record<string, never>;');
    barrelLines.push('  parameters: never;');
    barrelLines.push('  requestBodies: never;');
    barrelLines.push('  headers: Record<string, never>;');
    barrelLines.push('  pathItems: never;');
    barrelLines.push('}');
    barrelLines.push('export type operations = Record<string, never>;');
  } else {
    const nsJoin = (prop) => namespaces.map((ns) => `${ns}.${prop}`).join(' & ');
    barrelLines.push(`export type paths = ${nsJoin('paths')};`);
    barrelLines.push('export type webhooks = Record<string, never>;');
    barrelLines.push('export interface components {');
    barrelLines.push(`  schemas: ${nsJoin("components['schemas']")};`);
    barrelLines.push(`  responses: ${nsJoin("components['responses']")};`);
    // Some specs may not define these; keep them as never to match openapi-typescript defaults
    barrelLines.push('  parameters: never;');
    barrelLines.push('  requestBodies: never;');
    barrelLines.push(`  headers: ${nsJoin("components['headers']")};`);
    barrelLines.push('  pathItems: never;');
    barrelLines.push('}');
    barrelLines.push('export type operations = Record<string, never>;');
  }

  const barrelPath = path.resolve(projectRoot, 'src/types/api.generated.ts');
  await fsp.writeFile(barrelPath, barrelLines.join('\n') + '\n', 'utf8');

  // Done
  console.log(`âœ… Generated modular OpenAPI types for ${namespaces.length} tags.`);
  console.log('   - Output directory:', outDir);
  console.log('   - Compatibility barrel: src/types/api.generated.ts');
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
