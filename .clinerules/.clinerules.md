# AI Therapist Global Coding Standards & Best Practices

## Core Development Principles

### 1. Don't Repeat Yourself (DRY)
- **Extract Common Patterns**: Create utilities for repeated code blocks
- **Shared Constants**: Define constants once in dedicated files
- **Reusable Components**: Build composable UI components
- **Common Validations**: Use shared Zod schemas and validation functions
- **API Response Patterns**: Use standardized response helpers

### 2. SOLID Principles
- **Single Responsibility**: Each function/class should have one reason to change
- **Open/Closed**: Open for extension, closed for modification
- **Liskov Substitution**: Subtypes must be substitutable for base types
- **Interface Segregation**: Many client-specific interfaces over one general-purpose interface
- **Dependency Inversion**: Depend on abstractions, not concretions

### 3. Additional Core Principles
- **Principle of Least Privilege**: Grant minimum access necessary
- **Fail Fast**: Validate inputs early, throw descriptive errors
- **Composition over Inheritance**: Prefer composition patterns
- **Explicit is Better Than Implicit**: Make code intentions clear
- **Security by Design**: Security considerations from the start

## Therapeutic Application Standards

### 1. Data Sensitivity Requirements
```typescript
// ✅ REQUIRED: All therapeutic data must be encrypted at rest
interface TherapeuticMessage {
  id: string;
  content: string; // Encrypted with AES-256-GCM
  sessionId: string;
  createdAt: Date;
}

// ✅ REQUIRED: Use encryption utilities for sensitive data
import { encryptField, decryptField } from '@/lib/auth/crypto-utils';

// ✅ REQUIRED: Never log sensitive therapeutic content
logger.info('Processing message', { messageId, userId }); // ✅ Good
logger.info('Message content:', { content }); // ❌ Never do this
```

### 2. Professional Boundaries
```typescript
// ✅ REQUIRED: Validate all AI responses for professional appropriateness
const validateTherapeuticResponse = (response: string): boolean => {
  const forbiddenPatterns = [
    /medical diagnosis/i,
    /prescribe medication/i,
    /emergency contact/i
  ];
  return !forbiddenPatterns.some(pattern => pattern.test(response));
};
```

### 3. Audit Trail Requirements
```typescript
// ✅ REQUIRED: All therapeutic interactions must be auditable
interface AuditLog {
  action: string;
  userId: string;
  sessionId?: string;
  timestamp: Date;
  metadata: Record<string, unknown>;
}
```

## API Development Standards

### 1. Standardized Response Patterns
```typescript
// ✅ ALWAYS use standardized response helpers
import { createSuccessResponse, createErrorResponse } from '@/lib/api/api-response';

export const GET = withApiMiddleware(async (request, context) => {
  try {
    const data = await someOperation();
    return createSuccessResponse(data, { requestId: context.requestId });
  } catch (error) {
    return createServerErrorResponse(error as Error, context.requestId);
  }
});

// ❌ NEVER use raw NextResponse.json()
return NextResponse.json({ data }); // Don't do this
```

### 2. Middleware Composition Pattern
```typescript
// ✅ REQUIRED: Use middleware composition for complex requirements
export const POST = compose([
  withAuth('authenticated'),
  withRateLimit({ requests: 10, window: '1m' }),
  withValidation(userInputSchema),
  withAuditLogging
])(async (request, context, validatedData) => {
  // Handler logic with full context
});

// ✅ Create reusable middleware combinations
export const therapeuticEndpoint = compose([
  withAuth('authenticated'),
  withTherapeuticContext,
  withSessionValidation,
  withAuditLogging
]);
```

### 3. Error Handling Standards
```typescript
// ✅ REQUIRED: Use standardized error codes
const ERROR_CODES = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',
  THERAPEUTIC_BOUNDARY: 'THERAPEUTIC_BOUNDARY',
  SESSION_EXPIRED: 'SESSION_EXPIRED'
} as const;

// ✅ REQUIRED: Provide helpful error messages
return createErrorResponse(
  'Session has expired. Please start a new conversation.',
  401,
  {
    code: ERROR_CODES.SESSION_EXPIRED,
    suggestedAction: 'Click "New Session" to continue',
    requestId: context.requestId
  }
);
```

### 4. Input Validation Standards
```typescript
// ✅ REQUIRED: Define schemas in dedicated files
// schemas/user-input.ts
export const messageInputSchema = z.object({
  content: z.string()
    .min(1, 'Message cannot be empty')
    .max(4000, 'Message too long')
    .refine(isTherapeuticallyAppropriate, 'Content violates therapeutic guidelines'),
  sessionId: z.string().uuid('Invalid session ID')
});

// ✅ REQUIRED: Use withValidation middleware
export const POST = withValidation(
  messageInputSchema,
  async (request, context, validatedData) => {
    // validatedData is fully typed and validated
  }
);
```

## Component Development Standards

### 1. Component Structure Pattern
```typescript
// ✅ REQUIRED: Follow this component structure
interface ComponentProps {
  // Props interface first
  children?: React.ReactNode;
  className?: string;
  // ... other props
}

const Component = React.forwardRef<HTMLElement, ComponentProps>(
  ({ children, className, ...props }, ref) => {
    // 1. Hooks first
    const [state, setState] = useState();
    
    // 2. Computed values
    const computedValue = useMemo(() => calculate(state), [state]);
    
    // 3. Event handlers
    const handleClick = useCallback(() => {
      // Handle event
    }, []);
    
    // 4. Effects last
    useEffect(() => {
      // Side effects
    }, []);
    
    // 5. Render
    return (
      <div ref={ref} className={cn('base-styles', className)} {...props}>
        {children}
      </div>
    );
  }
);

Component.displayName = 'Component';
export { Component };
```

### 2. Therapeutic UI Standards
```typescript
// ✅ REQUIRED: Use therapeutic design system constraints
const TYPOGRAPHY = {
  header: 'text-3xl font-semibold',     // Main headers only
  section: 'text-xl font-semibold',     // Section headings
  body: 'text-base',                    // Chat messages, body text
  meta: 'text-sm'                       // Timestamps, metadata
} as const;

const SPACING = {
  xs: 'p-2',    // 8px
  sm: 'p-4',    // 16px
  md: 'p-6',    // 24px
  lg: 'p-8',    // 32px
  xl: 'p-12'    // 48px
} as const;

// ✅ REQUIRED: Follow 60/30/10 color rule
const COLORS = {
  primary: 'bg-background',        // 60% - neutral backgrounds
  secondary: 'text-foreground',    // 30% - text and subtle UI
  accent: 'bg-primary'             // 10% - therapeutic highlights
} as const;
```

### 3. Performance Optimization
```typescript
// ✅ REQUIRED: Optimize expensive components
const ExpensiveComponent = React.memo(({ data, onAction }) => {
  const processedData = useMemo(() => 
    expensiveCalculation(data), 
    [data]
  );
  
  const handleAction = useCallback((id: string) => {
    onAction(id);
  }, [onAction]);
  
  return <div>{/* render */}</div>;
});

// ✅ REQUIRED: Use loading states for async operations
const AsyncComponent = () => {
  const { data, isLoading, error } = useQuery(queryKey, queryFn);
  
  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorBoundary error={error} />;
  return <DataDisplay data={data} />;
};
```

## Database Operations Standards

### 1. Query Patterns
```typescript
// ✅ REQUIRED: Use transaction wrappers for multi-step operations
export const createTherapeuticSession = async (userId: string, initialMessage: string) => {
  return await withTransaction(async (prisma) => {
    const session = await prisma.session.create({
      data: { userId, title: generateTitle(initialMessage) }
    });
    
    const message = await prisma.message.create({
      data: {
        sessionId: session.id,
        content: await encryptField(initialMessage),
        role: 'user'
      }
    });
    
    return { session, message };
  });
};

// ✅ REQUIRED: Use typed query builders
export const getSessionMessages = async (sessionId: string) => {
  return await prisma.message.findMany({
    where: { sessionId },
    select: {
      id: true,
      content: true, // Will be decrypted by middleware
      role: true,
      createdAt: true
    },
    orderBy: { createdAt: 'asc' }
  });
};
```

### 2. Error Handling Patterns
```typescript
// ✅ REQUIRED: Standardized database error handling
export const withDatabaseErrorHandling = async <T>(
  operation: () => Promise<T>,
  context: string
): Promise<T> => {
  try {
    return await operation();
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      switch (error.code) {
        case 'P2002':
          throw new DatabaseError('Duplicate entry', 'UNIQUE_CONSTRAINT_VIOLATION');
        case 'P2025':
          throw new DatabaseError('Record not found', 'RECORD_NOT_FOUND');
        default:
          throw new DatabaseError(`Database operation failed: ${context}`, 'DATABASE_ERROR');
      }
    }
    throw error;
  }
};
```

## Security Requirements

### 1. Authentication & Authorization
```typescript
// ✅ REQUIRED: Always validate user context
export const requireAuth = (requiredRole?: UserRole) => {
  return (handler: AuthenticatedHandler) => {
    return withAuth(async (request, context) => {
      if (requiredRole && context.user.role !== requiredRole) {
        return createErrorResponse('Insufficient permissions', 403, {
          code: 'INSUFFICIENT_PERMISSIONS'
        });
      }
      return handler(request, context);
    });
  };
};

// ✅ REQUIRED: Rate limiting for sensitive operations
export const therapeuticRateLimit = withRateLimit({
  requests: 10,
  window: '1m',
  keyGenerator: (request, context) => `therapeutic:${context.user.id}`
});
```

### 2. Data Encryption Standards
```typescript
// ✅ REQUIRED: Encrypt all PII and therapeutic content
import { encryptField, decryptField } from '@/lib/auth/crypto-utils';

// ✅ REQUIRED: Use field-level encryption
const storeTherapeuticData = async (data: TherapeuticData) => {
  return await prisma.create({
    data: {
      ...data,
      content: await encryptField(data.content),
      notes: await encryptField(data.notes)
    }
  });
};

// ✅ REQUIRED: Validate encryption keys
if (!process.env.ENCRYPTION_KEY || process.env.ENCRYPTION_KEY.length < 64) {
  throw new Error('Invalid encryption key. Run: npm run encryption:generate');
}
```

### 3. Input Sanitization
```typescript
// ✅ REQUIRED: Sanitize all user inputs
import { sanitizeHtml, validateTherapeuticContent } from '@/lib/validation';

export const processUserMessage = (content: string): string => {
  // 1. Sanitize HTML
  const sanitized = sanitizeHtml(content);
  
  // 2. Validate therapeutic appropriateness
  if (!validateTherapeuticContent(sanitized)) {
    throw new ValidationError('Content violates therapeutic guidelines');
  }
  
  // 3. Length validation
  if (sanitized.length > MAX_MESSAGE_LENGTH) {
    throw new ValidationError('Message too long');
  }
  
  return sanitized;
};
```

## Testing Requirements

### 1. Test Structure Standards
```typescript
// ✅ REQUIRED: Follow AAA pattern (Arrange, Act, Assert)
describe('TherapeuticMessageService', () => {
  describe('createMessage', () => {
    it('should encrypt message content before storing', async () => {
      // Arrange
      const mockSession = await createTestSession();
      const messageContent = 'Test therapeutic message';
      
      // Act
      const result = await therapeuticMessageService.create({
        sessionId: mockSession.id,
        content: messageContent,
        role: 'user'
      });
      
      // Assert
      expect(result.content).not.toBe(messageContent); // Should be encrypted
      expect(result.content).toMatch(/^encrypted:/); // Should have encryption prefix
      
      // Verify decryption works
      const decrypted = await decryptField(result.content);
      expect(decrypted).toBe(messageContent);
    });
  });
});
```

### 2. Security Testing Requirements
```typescript
// ✅ REQUIRED: Test all security boundaries
describe('Authentication Security', () => {
  it('should prevent session hijacking', async () => {
    const validSession = await createAuthenticatedSession();
    const maliciousRequest = createMockRequest({
      headers: { 'x-forwarded-for': 'different-ip' },
      cookies: { sessionToken: validSession.token }
    });
    
    const response = await authMiddleware(maliciousRequest);
    expect(response.status).toBe(401);
  });
  
  it('should encrypt TOTP secrets', async () => {
    const user = await createTestUser();
    const totpSecret = generateTotpSecret();
    
    await storeUserTotp(user.id, totpSecret);
    
    const stored = await prisma.user.findUnique({
      where: { id: user.id },
      select: { totpSecret: true }
    });
    
    expect(stored.totpSecret).not.toBe(totpSecret);
    expect(stored.totpSecret).toMatch(/^encrypted:/);
  });
});
```

### 3. Coverage Requirements
```typescript
// ✅ REQUIRED: Maintain 100% test pass rate
// Current: 40 test suites, 769 tests passing

// ✅ REQUIRED: Test critical paths
const CRITICAL_PATHS = [
  'Authentication flows',
  'Data encryption/decryption',
  'Therapeutic content validation',
  'API security boundaries',
  'Database operations',
  'Session management'
];

// ✅ REQUIRED: Mock external dependencies
jest.mock('@/lib/ai/groq-client', () => ({
  streamCompletion: jest.fn().mockResolvedValue(mockAiResponse)
}));
```

## Performance Standards

### 1. Frontend Performance
```typescript
// ✅ REQUIRED: Optimize streaming animations
const StreamingMessage = ({ content }: { content: string }) => {
  const processedContent = useMemo(() => {
    return analyzeContentComplexity(content);
  }, [content]);
  
  const animationConfig = useMemo(() => ({
    stage: processedContent.hasComplexTables ? '3-stage' : 'simple',
    duration: processedContent.complexity > 0.7 ? 400 : 200
  }), [processedContent]);
  
  return (
    <div className={cn(
      'streaming-message',
      `animation-${animationConfig.stage}`
    )}>
      {content}
    </div>
  );
};

// ✅ REQUIRED: Use layout stability attributes
<table className="streaming-table" data-streaming-stable="true">
  {/* Table content */}
</table>
```

### 2. API Performance
```typescript
// ✅ REQUIRED: Implement response caching where appropriate
export const getCachedSessionData = cache(async (sessionId: string) => {
  return await prisma.session.findUnique({
    where: { id: sessionId },
    include: { messages: { take: 50, orderBy: { createdAt: 'desc' } } }
  });
});

// ✅ REQUIRED: Use streaming for AI responses
export const streamTherapeuticResponse = async (messages: Message[]) => {
  const stream = await streamText({
    model: groq('openai/gpt-oss-20b'),
    messages: messages.map(formatForAI),
    temperature: 0.7
  });
  
  return toUIMessageStreamResponse(stream);
};
```

## File Organization Standards

### 1. Directory Structure
```
src/
├── app/                    # Next.js App Router
│   ├── api/               # API routes
│   ├── (dashboard)/       # Route groups
│   └── globals.css        # Global styles
├── components/            # UI components
│   ├── ui/               # Base UI components
│   └── therapeutic/      # Domain-specific components
├── lib/                   # Utilities and services
│   ├── auth/             # Authentication utilities
│   ├── db/               # Database utilities
│   ├── ai/               # AI integration
│   └── validation/       # Validation schemas
├── types/                 # TypeScript type definitions
└── __tests__/            # Test files
    ├── components/       # Component tests
    ├── lib/              # Utility tests
    └── api/              # API tests
```

### 2. Import Organization
```typescript
// ✅ REQUIRED: Import order
// 1. React and Next.js
import React from 'react';
import { NextRequest } from 'next/server';

// 2. Third-party libraries
import { z } from 'zod';
import { Prisma } from '@prisma/client';

// 3. Internal utilities and types
import { cn } from '@/lib/utils';
import { ApiResponse } from '@/types/api';

// 4. Internal components
import { Button } from '@/components/ui/button';
import { TherapeuticLayout } from '@/components/therapeutic/layout';

// 5. Relative imports
import { validateInput } from './validation';
import { formatResponse } from '../utils/formatting';
```

## Documentation Standards

### 1. Code Comments
```typescript
// ✅ REQUIRED: JSDoc for public APIs
/**
 * Creates a new therapeutic session with encrypted storage
 * @param userId - The authenticated user's ID
 * @param initialMessage - The first message content (will be encrypted)
 * @returns Promise resolving to the created session with first message
 * @throws {ValidationError} When input validation fails
 * @throws {DatabaseError} When database operation fails
 */
export const createTherapeuticSession = async (
  userId: string,
  initialMessage: string
): Promise<SessionWithMessage> => {
  // Implementation
};

// ✅ REQUIRED: Security warnings for sensitive code
/**
 * ⚠️ SECURITY: This function handles sensitive therapeutic data
 * - Content is encrypted before database storage
 * - Audit logging is automatically applied
 * - Rate limiting enforced per user
 */
```

### 2. Type Definitions
```typescript
// ✅ REQUIRED: Comprehensive type documentation
/**
 * Represents a therapeutic session between user and AI
 */
interface TherapeuticSession {
  id: string;
  userId: string;
  title: string;
  /** ISO 8601 timestamp of session creation */
  createdAt: string;
  /** ISO 8601 timestamp of last activity */
  updatedAt: string;
  /** Encrypted therapeutic messages */
  messages: EncryptedMessage[];
}

// ✅ REQUIRED: Use branded types for security
type EncryptedString = string & { __brand: 'encrypted' };
type UserId = string & { __brand: 'userId' };
```

## Deployment Standards

### 1. Environment Validation
```typescript
// ✅ REQUIRED: Validate environment on startup
const requiredEnvVars = [
  'DATABASE_URL',
  'ENCRYPTION_KEY',
  'NEXTAUTH_SECRET'
] as const;

export const validateEnvironment = () => {
  const missing = requiredEnvVars.filter(key => !process.env[key]);
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
  
  // Validate encryption key strength
  if (!process.env.ENCRYPTION_KEY || process.env.ENCRYPTION_KEY.length < 64) {
    throw new Error('ENCRYPTION_KEY must be at least 64 characters. Run: npm run encryption:generate');
  }
};
```

### 2. Health Checks
```typescript
// ✅ REQUIRED: Comprehensive health checks
export const healthCheck = async (): Promise<HealthStatus> => {
  const checks = await Promise.allSettled([
    checkDatabase(),
    checkEncryption(),
    checkAIService(),
    checkMemoryUsage()
  ]);
  
  return {
    status: checks.every(c => c.status === 'fulfilled') ? 'healthy' : 'unhealthy',
    timestamp: new Date().toISOString(),
    checks: formatHealthChecks(checks)
  };
};
```

## Enforcement Rules

### 1. Pre-commit Hooks
```typescript
// ✅ REQUIRED: Run before every commit
const preCommitChecks = [
  'npm run lint',           // ESLint validation
  'npm run test',           // Full test suite (must maintain 100% pass rate)
  'npm run build',          // Build validation
  'npm run security-audit'  // Security vulnerability scan
];
```

### 2. Code Review Requirements
```typescript
// ✅ REQUIRED: All changes must pass these checks
const codeReviewChecklist = [
  'Security: No sensitive data in logs or comments',
  'Testing: All new code covered by tests',
  'Performance: No unnecessary re-renders or database queries',
  'Accessibility: UI changes include ARIA labels',
  'Types: No `any` types without justification',
  'Documentation: Public APIs documented with JSDoc'
];
```

### 3. Breaking Change Process
```typescript
// ✅ REQUIRED: Process for breaking changes
interface BreakingChangeProcess {
  1: 'Create deprecation warnings';
  2: 'Update documentation';
  3: 'Provide migration guide';
  4: 'Maintain backward compatibility for one release';
  5: 'Remove deprecated code with major version bump';
}
```

---

## Quick Reference

### Command Checklist
```bash
# Before committing
npm run lint          # Check code quality
npm run test          # Verify all tests pass (maintain 100% rate)
npm run build         # Validate build

# Security validation
npm run encryption:validate  # Check encryption key
npm run security-audit      # Vulnerability scan

# Performance monitoring
npm run dev           # Development with Turbopack
npm run build         # Production build check
```

### Essential Imports
```typescript
// Response handling
import { createSuccessResponse, createErrorResponse } from '@/lib/api/api-response';

// Validation
import { z } from 'zod';
import { withValidation } from '@/lib/api/middleware';

// Security
import { withAuth, withRateLimit } from '@/lib/api/middleware';
import { encryptField, decryptField } from '@/lib/auth/crypto-utils';

// UI utilities
import { cn } from '@/lib/utils';
import React from 'react';
```

### Common Patterns
```typescript
// API endpoint structure
export const POST = compose([
  withAuth('authenticated'),
  withRateLimit({ requests: 10, window: '1m' }),
  withValidation(inputSchema)
])(async (request, context, validatedData) => {
  try {
    const result = await businessLogic(validatedData);
    return createSuccessResponse(result, { requestId: context.requestId });
  } catch (error) {
    return createServerErrorResponse(error as Error, context.requestId);
  }
});

// Component structure
const Component = React.forwardRef<HTMLElement, Props>(
  ({ className, ...props }, ref) => {
    return (
      <div ref={ref} className={cn('base-styles', className)} {...props}>
        {/* Content */}
      </div>
    );
  }
);
```

**Maintain Excellence**: This project has achieved 40 test suites with 769 passing tests (100% pass rate) and comprehensive security implementation. These standards ensure we maintain this excellence while enabling efficient development.