/**
 * Chat UI Hook
 *
 * Consolidated hook for all UI-specific chat concerns including:
 * - Input state management
 * - Loading/generating states
 * - Sidebar visibility
 * - Viewport detection (mobile/desktop)
 * - DOM element refs
 * - Focus management
 *
 * This hook is independent of message data and handles purely UI concerns.
 */

'use client';

import { useEffect, useRef, useState, useCallback, useMemo } from 'react';

/**
 * UI state interface returned by the hook.
 */
export interface ChatUIState {
  /** Current value of the user input field */
  input: string;
  /** Whether a message is currently being generated by the AI */
  isLoading: boolean;
  /** Whether a therapy report is currently being generated */
  isGeneratingReport: boolean;
  /** Whether the sidebar is visible */
  showSidebar: boolean;
  /** Whether the app is running on a mobile device */
  isMobile: boolean;
  /** CSS height value for the viewport */
  viewportHeight: string;
}

/**
 * UI refs interface returned by the hook.
 */
export interface ChatUIRefs {
  /** Ref to the textarea element for user input */
  textareaRef: React.RefObject<HTMLTextAreaElement | null>;
  /** Ref to the messages container for scrolling control */
  messagesContainerRef: React.RefObject<HTMLDivElement | null>;
  /** Ref to the input container for height calculations */
  inputContainerRef: React.RefObject<HTMLDivElement | null>;
}

/**
 * UI actions interface returned by the hook.
 */
export interface ChatUIActions {
  /** Updates the input field value */
  setInput: (value: string) => void;
  /** Sets the loading state */
  setIsLoading: (value: boolean) => void;
  /** Sets the report generating state */
  setIsGeneratingReport: (value: boolean) => void;
  /** Sets the sidebar visibility */
  setShowSidebar: (value: boolean) => void;
  /** Focuses the textarea input */
  focusInput: () => void;
  /** Schedules focus on the textarea after a delay */
  scheduleFocus: (delayMs?: number) => void;
}

/**
 * Combined hook for all chat UI concerns.
 * Consolidates UI state, refs, and viewport handling.
 *
 * @returns Object containing UI state, refs, and actions
 *
 * @example
 * ```tsx
 * function ChatPage() {
 *   const { state, refs, actions } = useChatUI();
 *
 *   const handleSubmit = () => {
 *     if (state.input.trim() && !state.isLoading) {
 *       sendMessage(state.input);
 *       actions.setInput('');
 *       actions.setIsLoading(true);
 *     }
 *   };
 *
 *   return (
 *     <div style={{ height: state.viewportHeight }}>
 *       <textarea
 *         ref={refs.textareaRef}
 *         value={state.input}
 *         onChange={(e) => actions.setInput(e.target.value)}
 *       />
 *     </div>
 *   );
 * }
 * ```
 */
export function useChatUI(): { state: ChatUIState; refs: ChatUIRefs; actions: ChatUIActions } {
  // Input and loading state
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showSidebar, setShowSidebar] = useState(true);
  const [isGeneratingReport, setIsGeneratingReport] = useState(false);

  // Viewport state
  const [isMobile, setIsMobile] = useState(false);
  const [viewportHeight, setViewportHeight] = useState('100vh');

  // Refs
  const textareaRef = useRef<HTMLTextAreaElement | null>(null);
  const messagesContainerRef = useRef<HTMLDivElement | null>(null);
  const inputContainerRef = useRef<HTMLDivElement | null>(null);
  const focusTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Focus management
  const clearFocusTimeout = useCallback(() => {
    if (focusTimeoutRef.current) {
      clearTimeout(focusTimeoutRef.current);
      focusTimeoutRef.current = null;
    }
  }, []);

  const focusInput = useCallback(() => {
    textareaRef.current?.focus();
  }, []);

  const scheduleFocus = useCallback(
    (delayMs = 50) => {
      clearFocusTimeout();
      focusTimeoutRef.current = setTimeout(() => {
        focusTimeoutRef.current = null;
        focusInput();
      }, delayMs);
    },
    [clearFocusTimeout, focusInput]
  );

  // Initial focus
  useEffect(() => {
    scheduleFocus();
    return clearFocusTimeout;
  }, [scheduleFocus, clearFocusTimeout]);

  // Focus after loading completes
  useEffect(() => {
    if (!isLoading) {
      scheduleFocus();
    }
  }, [isLoading, scheduleFocus]);

  // Viewport detection
  useEffect(() => {
    const updateViewport = () => {
      const mobile = window.innerWidth < 768;
      setIsMobile(mobile);

      if (mobile) {
        const actualHeight = Math.min(window.innerHeight, window.screen.height);
        const value = `${actualHeight}px`;
        setViewportHeight(value);
        document.documentElement.style.setProperty('--app-height', value);
        document.documentElement.style.setProperty('--vh', `${actualHeight * 0.01}px`);
      } else {
        setViewportHeight('100vh');
        document.documentElement.style.removeProperty('--app-height');
        document.documentElement.style.removeProperty('--vh');
      }
    };

    updateViewport();

    let resizeTimeout: NodeJS.Timeout;
    const handleResize = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(updateViewport, 150);
    };

    const handleOrientationChange = () => setTimeout(updateViewport, 300);

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleOrientationChange);

    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('orientationchange', handleOrientationChange);
      clearTimeout(resizeTimeout);
    };
  }, []);

  // Memoize state object
  const state = useMemo<ChatUIState>(
    () => ({
      input,
      isLoading,
      isGeneratingReport,
      showSidebar,
      isMobile,
      viewportHeight,
    }),
    [input, isLoading, isGeneratingReport, showSidebar, isMobile, viewportHeight]
  );

  // Memoize refs object
  const refs = useMemo<ChatUIRefs>(
    () => ({
      textareaRef,
      messagesContainerRef,
      inputContainerRef,
    }),
    []
  );

  // Memoize actions object
  const actions = useMemo<ChatUIActions>(
    () => ({
      setInput,
      setIsLoading,
      setIsGeneratingReport,
      setShowSidebar,
      focusInput,
      scheduleFocus,
    }),
    [focusInput, scheduleFocus]
  );

  return { state, refs, actions };
}
