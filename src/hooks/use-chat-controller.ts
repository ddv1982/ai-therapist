/**
 * Chat Controller Hook
 *
 * Central orchestration hook for the therapy chat application.
 * Composes specialized hooks into a unified API for the UI layer.
 *
 * @module useChatController
 */

'use client';

import { useCallback } from 'react';
import type { MessageData } from '@/features/chat/messages/message';
import { useChatMessages } from './use-chat-messages';
import { useScrollToBottom } from './use-scroll-to-bottom';
import { logger } from '@/lib/utils/logger';
import { useTranslations } from 'next-intl';
import { useChatTransport } from '@/hooks/use-chat-transport';
import { useMemoryContext } from '@/hooks/use-memory-context';
import { useApiKeys } from '@/hooks/use-api-keys';
import { useChatSessions } from '@/hooks/chat/use-chat-sessions';
import { useChatUI } from '@/hooks/chat/use-chat-ui';
import { useChatStreaming } from '@/hooks/chat/use-chat-streaming';
import { useSendMessage } from '@/hooks/chat/use-send-message';
import { useGenerateReport } from '@/hooks/chat/use-generate-report';
import type { ObsessionsCompulsionsData } from '@/types';
import type { UiSession } from '@/features/chat/lib/session-mapper';
import type { MemoryContextInfo } from '@/features/chat/lib/memory-utils';

type Message = MessageData;

/**
 * UI representation of a chat session.
 * @typedef {UiSession} ChatSessionSummary
 */
export type ChatSessionSummary = UiSession;

/**
 * Interface for the chat controller, providing all state and actions
 * needed to manage the therapy chat application.
 *
 * @interface ChatController
 */
export interface ChatController {
  /** Array of all messages in the current session */
  messages: Message[];
  /** Array of all available chat sessions */
  sessions: ChatSessionSummary[];
  /** ID of the currently active session, or null if no session is active */
  currentSession: string | null;
  /** Current value of the user input field */
  input: string;
  /** Whether a message is currently being generated by the AI */
  isLoading: boolean;
  /** Whether the app is running on a mobile device */
  isMobile: boolean;
  /** CSS height value for the viewport (e.g., "100vh" or "calc(100vh - env(...))") */
  viewportHeight: string;
  /** Whether a therapy report is currently being generated */
  isGeneratingReport: boolean;
  /** Current memory context information for the active session */
  memoryContext: MemoryContextInfo;

  /** Ref to the textarea element for user input */
  textareaRef: React.RefObject<HTMLTextAreaElement | null>;
  /** Ref to the messages container for scrolling control */
  messagesContainerRef: React.RefObject<HTMLDivElement | null>;
  /** Ref to the input container for height calculations */
  inputContainerRef: React.RefObject<HTMLDivElement | null>;

  /** Whether the user is scrolled near the bottom of the messages */
  isNearBottom: boolean;
  /** Scrolls the messages container to the bottom */
  scrollToBottom: (force?: boolean, delay?: number) => void;

  /** Updates the input field value */
  setInput: (value: string) => void;
  /** Sends the current input as a user message */
  sendMessage: () => Promise<void>;
  /** Stops the current AI generation (message or report) */
  stopGenerating: () => void;
  /** Creates a new chat session and switches to it */
  startNewSession: () => void;
  /** Deletes a specific session and its messages */
  deleteSession: (sessionId: string) => Promise<void>;
  /** Reloads all sessions from the backend */
  loadSessions: () => Promise<void>;
  /** Switches to a specific session and syncs its state */
  setCurrentSessionAndSync: (sessionId: string) => Promise<void>;
  /** Generates a therapy report for the current session */
  generateReport: () => Promise<void>;

  /** Controls sidebar visibility */
  setShowSidebar: (value: boolean) => void;
  /** Current sidebar visibility state */
  showSidebar: boolean;
  /** Updates the memory context info */
  setMemoryContext: (info: MemoryContextInfo) => void;

  /** Adds a message to the chat (used by UI bridges) */
  addMessageToChat: (message: {
    content: string;
    role: 'user' | 'assistant';
    sessionId: string;
    modelUsed?: string;
    source?: string;
    metadata?: Record<string, unknown>;
  }) => Promise<{ success: boolean; error?: string }>;

  /** Updates metadata for a specific message */
  updateMessageMetadata: (
    sessionId: string,
    messageId: string,
    metadata: Record<string, unknown>,
    options?: { mergeStrategy?: 'merge' | 'replace' }
  ) => Promise<{ success: boolean; error?: string }>;

  /** Creates an obsessions/compulsions tracking table */
  createObsessionsCompulsionsTable: () => Promise<{ success: boolean; error?: string }>;
}

/**
 * Primary chat controller hook for the therapy application.
 * Orchestrates all chat functionality including messages, sessions, streaming,
 * memory context, and UI state management.
 *
 * This hook combines multiple specialized hooks into a unified API, providing
 * a single interface for all chat-related operations. It manages the complete
 * lifecycle of therapy sessions from creation to deletion.
 *
 * @param {Object} [options] - Configuration options for the chat controller
 * @param {string} options.model - AI model ID to use for chat (e.g., 'gpt-4')
 * @param {boolean} options.webSearchEnabled - Whether to enable web search capabilities
 * @returns {ChatController} Complete chat controller interface with state and actions
 *
 * @example
 * ```tsx
 * function ChatPage() {
 *   const controller = useChatController({
 *     model: 'gpt-4',
 *     webSearchEnabled: false
 *   });
 *
 *   return (
 *     <div>
 *       <ChatHeader
 *         onNewSession={controller.startNewSession}
 *         sessions={controller.sessions}
 *       />
 *       <MessageList messages={controller.messages} />
 *       <ChatInput
 *         value={controller.input}
 *         onChange={controller.setInput}
 *         onSend={controller.sendMessage}
 *         disabled={controller.isLoading}
 *       />
 *     </div>
 *   );
 * }
 * ```
 */
export function useChatController(options?: {
  model: string;
  webSearchEnabled: boolean;
}): ChatController {
  const {
    messages,
    loadMessages,
    addMessageToChat: addMessageToChatInternal,
    clearMessages,
    setMessages,
    updateMessageMetadata,
  } = useChatMessages();

  const t = useTranslations();
  const resolveDefaultTitle = useCallback((): string => {
    const val = t('sessions.defaultTitle');
    return typeof val === 'string' && val.length > 0 ? val : 'New Chat';
  }, [t]);

  const {
    sessions,
    currentSession,
    loadSessions,
    ensureActiveSession,
    startNewSession: resetSessionState,
    deleteSession,
    setCurrentSessionAndLoad,
  } = useChatSessions({ loadMessages, clearMessages, resolveDefaultTitle });

  const { memoryContext, setMemoryContext } = useMemoryContext(currentSession);

  // Get BYOK key if active
  const { keys: apiKeys, isActive: byokActive } = useApiKeys();
  const byokKey = byokActive ? (apiKeys.openai ?? null) : null;

  // UI state (input, loading, viewport, refs)
  const { state: uiState, refs: uiRefs, actions: uiActions } = useChatUI();
  const { input, isLoading, showSidebar, isGeneratingReport, isMobile, viewportHeight } = uiState;
  const { textareaRef, messagesContainerRef, inputContainerRef } = uiRefs;
  const { setInput, setIsLoading, setShowSidebar, setIsGeneratingReport, scheduleFocus } =
    uiActions;

  const { scrollToBottom, isNearBottom } = useScrollToBottom({
    isStreaming: isLoading,
    messages,
    container: messagesContainerRef.current,
    behavior: 'smooth',
    respectUserScroll: true,
  });

  const transport = useChatTransport({
    sessionId: currentSession,
    selectedModel: options?.model,
    byokKey,
  });

  const { startStream, stopStream } = useChatStreaming({
    currentSession,
    transport,
    options,
    setMessages,
    loadSessions,
    setIsLoading,
    byokKey,
  });

  const { sendMessage } = useSendMessage({
    ensureActiveSession,
    setMessages,
    setInput,
    setIsLoading,
    startStream,
    textareaRef,
  });

  const setCurrentSessionAndSync = useCallback(
    async (sessionId: string) => {
      await setCurrentSessionAndLoad(sessionId);
    },
    [setCurrentSessionAndLoad]
  );

  const startNewSession = useCallback(() => {
    void (async () => {
      await resetSessionState();
      scheduleFocus(100);
    })();
  }, [resetSessionState, scheduleFocus]);

  const sendMessageHandler = useCallback(async () => {
    const messageText = input;
    if (!messageText.trim() || isLoading) return;
    try {
      await sendMessage(messageText);
    } catch (error) {
      logger.error(
        'Error sending message to AI',
        { component: 'useChatController' },
        error instanceof Error ? error : new Error(String(error))
      );
    }
  }, [input, isLoading, sendMessage]);

  const stopGenerating = useCallback(() => {
    stopStream();
    scheduleFocus(50);
  }, [stopStream, scheduleFocus]);

  const { generateReport } = useGenerateReport({
    currentSession,
    messages,
    setMessages,
    loadSessions,
    setIsGeneratingReport,
  });

  const createObsessionsCompulsionsTable = useCallback(async (): Promise<{
    success: boolean;
    error?: string;
  }> => {
    let sessionId: string;
    try {
      sessionId = await ensureActiveSession();
    } catch (error) {
      logger.error(
        'Failed to ensure session for obsessions table',
        { component: 'useChatController' },
        error instanceof Error ? error : new Error(String(error))
      );
      return { success: false, error: 'Could not prepare a session for the tracker.' };
    }

    const baseData: ObsessionsCompulsionsData = {
      obsessions: [],
      compulsions: [],
      lastModified: new Date().toISOString(),
    };

    const { formatObsessionsCompulsionsForChat } = await import(
      '@/features/therapy/obsessions-compulsions/utils/format-obsessions-compulsions'
    );
    const tableContent = formatObsessionsCompulsionsForChat(baseData);

    // Create obsessions and compulsions table message
    const result = await addMessageToChatInternal({
      content: tableContent,
      role: 'user',
      sessionId,
      metadata: {
        type: 'obsessions-compulsions-table',
        step: 'obsessions-compulsions',
        data: baseData,
        dismissed: false,
        dismissedReason: null,
      },
    });
    if (!result.success) {
      logger.error('Failed to add obsessions tracker message', {
        component: 'useChatController',
        operation: 'createObsessionsCompulsionsTable',
        sessionId,
        error: result.error,
      });
      return { success: false, error: result.error ?? 'Failed to add the tracker message.' };
    }

    return { success: true };
  }, [ensureActiveSession, addMessageToChatInternal]);

  return {
    messages,
    sessions,
    currentSession,
    input,
    isLoading,
    isMobile,
    viewportHeight,
    isGeneratingReport,
    memoryContext,
    textareaRef,
    messagesContainerRef,
    inputContainerRef,
    isNearBottom,
    scrollToBottom,
    setInput,
    sendMessage: sendMessageHandler,
    stopGenerating,
    startNewSession,
    deleteSession,
    loadSessions,
    setCurrentSessionAndSync,
    generateReport,
    setShowSidebar,
    showSidebar,
    addMessageToChat: addMessageToChatInternal,
    updateMessageMetadata,
    setMemoryContext,
    createObsessionsCompulsionsTable,
  };
}
